import hpbandster  # BOHB
import numpy as np
import hpbandster.core.nameserver as hpns
from hpbandster.optimizers import BOHB as BOHB
import pandas as pd


class HyperParameterTuningLoop():
    '''
    What is the input?
    HyperParameterTuningLoop receives a DataFrame that is has continous days (two consecutive days in two consecutive rows), might contain multiple medical centers, is not normalized.
    hyper_parameter_space

    What does it output?
    It outputs returns a HyperParameterTuningLoop object.
    object.optimal_hyper_parameter_value_combination  # The contains the optimal hyper-parameter value combiantion
    object.tune_history  # undefined yet
    all inputs should also be contained in the object

    inputs:
    Worker
    lazy
    hyper_parameter_space   # the seed should have been set before hand

    # inputs only specific to our worker
    below are content of worker_specific_parameter_to_value_dictionary
        DataFrame
        loss_function
        number_of_days_to_predict_ahead
        number_of_test_days_in_a_day_level_DataFrame
        number_of_rolling_forecast_days
        data_windowing_option
        input_length
        lstm_is_many_to_many
        do_normalization

    nameserver_run_id
    nameserver_address
    nameserver_port
    min_budget = 50
    max_budget = 500
    n_iterations = 15

    The DataFrame is ususally generated by removing the last day's data (for all medical centers, if ) from an unnormalized day-level DataFrame generated after delimiting and normalization.

    Given a hyper-parameter space and a function that evaluates the geenrated hyper-parameter value combination, performs a number of hyper-parameter value combination generation and function evaluation, and return the best hyper-parameter value combination.

    outputs:
    bohb_result
    run_result_dataframe_sorted_by_loss_and_budget

    number_of_hyper_parameter_value_combination_evaluated
    number_of_unique_hyper_parameter_value_combination_evaluated

    number_of_total_budget_spent  # can be seen as total time spent in the automl loop
    number_of_equivalent_max_budget_computation  # equivalent to the number of times a max budget-hyperparameter value combination evaluation are done

    optimal_partial_hyper_parameter_value_combination_found_among_max_budget_evaluations
    info_of_optimal_partial_hyper_parameter_value_combination_found_among_max_budget_evaluations

    optimal_partial_hyper_parameter_value_combination_found_among_all_budget_evaluations
    info_of_optimal_partial_hyper_parameter_value_combination_found_among_all_budget_evaluations

    '''


    #
    '''
    for each hyper-parameter 
        evaluate

    '''
    #
    def __init__(self, CustomizedWorker, worker_specific_parameter_to_value_dictionary, hyper_parameter_space, nameserver_run_id, nameserver_address, nameserver_port, min_budget=50, max_budget=500, n_iterations=15, lazy=False):
        # inputs
        self.CustomizedWorker = CustomizedWorker  # the Worker class as implemented according to BOHB
        self.customized_worker_specific_parameter_to_value_dictionary = worker_specific_parameter_to_value_dictionary
        self.hyper_parameter_space = hyper_parameter_space

        self.nameserver_run_id = nameserver_run_id
        self.nameserver_address = nameserver_address  # address and run id can be the same across multithreading or instances but not nameserver_port
        self.nameserver_port = nameserver_port  # dont be 80, 8080, 443 or below 1024
        self.min_budget = min_budget  # budget might have decimal numbers, turn budget to epoch by using int() e.g. int(9.3) -> 9
        self.max_budget = max_budget
        self.number_of_iterations = n_iterations  # number of successive halfings to perform in BOHB
        self.lazy = lazy

        # outputs
        self.bohb_result = None
        self.run_result_dataframe_sorted_by_loss_and_budget = None

        self.number_of_hyper_parameter_value_combination_evaluated = None
        self.number_of_unique_hyper_parameter_value_combination_evaluated = None

        self.number_of_total_budget_spent = None  # can be seen as total time spent in the automl loop
        self.number_of_equivalent_max_budget_computation = None  # equivalent to the number of times a max budget-hyperparameter value combination evaluation are done

        self.optimal_partial_hyper_parameter_value_combination_found_among_max_budget_evaluations = {}  # partial because it does not contain budget
        self.info_of_optimal_partial_hyper_parameter_value_combination_found_among_max_budget_evaluations = {}

        self.optimal_partial_hyper_parameter_value_combination_found_among_all_budget_evaluations = {}
        self.info_of_optimal_partial_hyper_parameter_value_combination_found_among_all_budget_evaluations = {}

        if not lazy:
            self.start_tuning()
            self.generate_output_variables()

    # start of tuning
    def start_tuning(self):
        '''  Intro to BOHB mechanism
        BOHB does successive halving for many iterations.

        In the first iteration (successive halfing), there are many stages. In the first stage, a number of hyperparameter value combinations will be generated (in some way), and all of them will be evaluated using a small budget; among them, several best performing ones advance to the second stage and will be evaluated using a larger budget; this goes on and on with fewer and fewer hyperparameter value combinations and with larger and larger budget.

        In the second iteration, there are also many stages and stages will have gradually fewer hyperparemter value combinations and larger budget. The change made is that, in the first stage, a smaller number of hyperparemter value combination (compared to the first stage of the first iteration), and a larger budget will be used. The last stage of all iterations, however, will have the same budget.

        In terms of generating hyperparaemter value combiantions, models are built respectively for each budget (there is no distinction between iterations). Each budget will have a surrogate model and the model will be used for generating hyperparameter value combinations when the model has been built with enough hyperparemter value combiatnion evaluation records (under the model's budget).

        '''
        name_server = hpns.NameServer(run_id=self.nameserver_run_id, host=self.nameserver_address, port=self.nameserver_port)   # necessary to provide None
        name_server.start()

        worker = self.CustomizedWorker(nameserver=self.nameserver_address, run_id=self.nameserver_run_id, nameserver_port=self.nameserver_port, customized_worker_specific_parameter_to_value_dictionary=self.customized_worker_specific_parameter_to_value_dictionary)

        worker.run(background=True)

        bohb = BOHB(configspace=self.hyper_parameter_space, run_id=self.nameserver_run_id, nameserver=self.nameserver_address, nameserver_port=self.nameserver_port, min_budget=self.min_budget, max_budget=self.max_budget)

        self.bohb_result = bohb.run(n_iterations=self.number_of_iterations)

        bohb.shutdown(shutdown_workers=True)
        name_server.shutdown()

    @staticmethod
    def get_sorted_runs_dataframe(bohb_result):
        '''Sorted by loss and budgets (epochs) to make the hyper-parameter value combination with the smallest loss and budget on the top
        Output: a dataframe where the rows are BOHB runs (defined to be calling compute once); the last few columns are hyperparaemters, the rests are id of the run (the smaller the number, the earlier the run), budget used for the run, and loss of the run.
        '''
        id_to_hyper_parameter_value_combination_dictionary = bohb_result.get_id2config_mapping()
        all_runs_results = bohb_result.get_all_runs()

        id_list = []
        budget_list = []
        loss_list = []

        hyper_parameter_name_to_value_dictionary_list = []   # store hyperparemter value combination of each run

        for i in range(len(all_runs_results)):
            current_run = all_runs_results[i]

            id_of_the_current_run = current_run.config_id
            budget_of_the_current_run = current_run.budget
            loss_of_the_current_run = current_run.loss

            id_list.append(id_of_the_current_run)
            budget_list.append(budget_of_the_current_run)
            loss_list.append(loss_of_the_current_run)

            hyper_parameter_name_to_value_dictionary = id_to_hyper_parameter_value_combination_dictionary[id_of_the_current_run]['config']
            hyper_parameter_name_to_value_dictionary_list.append(hyper_parameter_name_to_value_dictionary)

        id_budget_loss_dataframe = pd.DataFrame({'id': id_list, 'budget': budget_list, 'loss': loss_list})   # the dataframe for info associated with the hyperparemter value combination
        hyper_parameter_value_combination_dataframe = pd.DataFrame(hyper_parameter_name_to_value_dictionary_list)  # the dataframe for hyperparameter value combination

        complete_result_dataframe = pd.concat([id_budget_loss_dataframe, hyper_parameter_value_combination_dataframe], axis=1).sort_values(['loss', 'budget'])

        return complete_result_dataframe

    def generate_output_variables(self):
        self.run_result_dataframe_sorted_by_loss_and_budget = self.get_sorted_runs_dataframe(self.bohb_result)

        self.number_of_hyper_parameter_value_combination_evaluated = len(self.run_result_dataframe_sorted_by_loss_and_budget.id)  # 65
        self.number_of_unique_hyper_parameter_value_combination_evaluated = len(self.run_result_dataframe_sorted_by_loss_and_budget.id.unique())  # 46

        # can be seen as total time spent in the automl loop
        self.number_of_total_budget_spent = self.run_result_dataframe_sorted_by_loss_and_budget.budget.sum()  # 3645
        # equivalent to the number of times a max budget-hyperparameter value combination evaluation are done
        self.number_of_equivalent_max_budget_computation = self.run_result_dataframe_sorted_by_loss_and_budget.budget.sum() / self.max_budget  # 15

        self.optimal_partial_hyper_parameter_value_combination_found_among_max_budget_evaluations = dict(self.run_result_dataframe_sorted_by_loss_and_budget[self.run_result_dataframe_sorted_by_loss_and_budget.budget == self.max_budget].sort_values('loss').iloc[0, 3:])  # {'x': 3.4151701294818765e-06}
        self.info_of_optimal_partial_hyper_parameter_value_combination_found_among_max_budget_evaluations = dict(self.run_result_dataframe_sorted_by_loss_and_budget[self.run_result_dataframe_sorted_by_loss_and_budget.budget == self.max_budget].sort_values('loss').iloc[0,])  # {'id': (2, 0, 2), 'budget': 243.0, 'loss': 243.00000341517014, 'x': 3.4151701294818765e-06}

        self.optimal_partial_hyper_parameter_value_combination_found_among_all_budget_evaluations = dict(self.run_result_dataframe_sorted_by_loss_and_budget.sort_values('loss').iloc[0, 3:])  # {'x': 1.8673196127170794e-05}
        self.info_of_optimal_partial_hyper_parameter_value_combination_found_among_all_budget_evaluations = dict(self.run_result_dataframe_sorted_by_loss_and_budget.sort_values('loss').iloc[0,])  # {'id': (0, 0, 25), 'budget': 9.0, 'loss': 9.000018673196127, 'x': 1.8673196127170794e-05}

    @staticmethod
    def budget_list_calculator(min_budget, max_budget, eta=3):
        max_SH_iter = -int(np.log(min_budget / max_budget) / np.log(eta)) + 1
        budgets = max_budget * np.power(eta, -np.linspace(max_SH_iter - 1, 0, max_SH_iter))
        return budgets
    # budget_list_calculator(min_budget=9, max_budget=248)  # array([  9.18518519,  27.55555556,  82.66666667, 248.        ])
    # budget_list_calculator(min_budget=9, max_budget=90)  # array([10., 30., 90.])

